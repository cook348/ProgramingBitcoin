# Chapter 1 - Finite Fields
Settying up Jupyter in VS Code is pretty neat.  That prevents me from having to go back and forth with the browser.  

A finite field is a set of numbers and two operations (addition and multiplication) that meet 4 criteria:
1. the set is closed (a+b and a*b are in the set)
2. additive identity
3. multiplicative identity
4. additive inverse
5. multiplicative inverse

Addition and mutliplication can be defined in a different way than we typically think of it in order to satisfy these requirements.  This can be done using modulo for example.  

a +f b = (a+b)%p
-f a = (-a)%p
a -f b = (a-b)%p

multiplication is very similar:
a *f b = (a * b) % p

and from there exponentiation:

a ^f b = (a^b) % p

Division is also closed, meaning that dividing any two numbers in the set results in another number in the set, which is a little wild.  

Fermat's little therom is used to derive division in the finite field.  
n^(p-1) % p = 1  where p is prime

Optimization note: in Python the pow function that takes a third argument applies the modulo of that argument after each round of multiplication, which is more efficient for some reason.  

The redefining exponentiation stuff went a little over my head, but hopefully that isn't important.  


# Chapter 2 - Elliptic Curves

The ellpitic curve is:
y^2 = x^3 + a*x + b 

secp256k1 elliptic curve:
y^2 = x^3 + 7

Addition of points in elliptic curves is a little different.  
 - Draw a line through points A and B and find the third intersection of the curve C
 - Reflect that across the X axis to get A + B

# Chapter 3 - Elliptic Curve Cryptography

We combine what we've learned in the last two chapters and apply finite field addition and multiplication to elliptic curves, which is straightforward because we've already overridden the symbols for add and multiply.  Addition is nonlinear when applying elliptic curves to a finite field making multiplication straightforward but division very difficult.  This is refered to as the discrete log problem and is the basis for elliptic curve cryptography (it's easier just to think of it as the "discrete point division problem").  

The ability to easily calculate in one direction and not the reverse is referred to in this context as asymetry.  

Binary expansion is used to make multiplication of large numbers more efficient.  It can be done in log2(n) time this way.  I don't really understand what's going on.  This is probably because I never really took the time to understand bitwise operations.  

## Defining the Curve for Bitcoin
The secp256k1 elliptic curve is the one used for Bitcoin.  Any curve is defined by: 
 - a and b
 - the prime, p
 - x and y coordinates of the Generator point, G
 - the order of the group generated by G, n

 Takeaways:
  - p is very close to 2^256, which is very big (like the number of atoms in the galaxy big) and can be expressed in 32 bits.  

## Public Key Cryptography
P = eG
we can calculate P easily given e and G, but we cannot figure out e easily given P and G due to the discrete log problem.  
e = Private Key (single 256 bit number)
P = Publick Key (x and y coordinates are 256 bit numbers)

The task is proving that we know a secret number without revealing the secret number itself.  

A bunch of equation that I sort of followed that I can summarize as, "you take a public key and the hash of whatever data was signed along with the signature, and from that and the definition of the signature, you can determine whether the signer signed with the right private key or not.  

# Chapter 4 - Serialization
There's a mix of big and little endian-ness in Bitcoin, so this should be fun.  

Hex = 4 bits per character
Base64 = 6 bits per character => 44 characters for compressed SEC format for the public key
Base58 is Base64 with easily mistaken characters removed => 5.86 bits per character
    - Base58 is on the way out in favor of Bech32, currently only used in Segwit

WIF (Wallet Import Format) - used to transfer the private key (not typically broadcast of course, but used to transfer the secret from one wallet to another.  )
